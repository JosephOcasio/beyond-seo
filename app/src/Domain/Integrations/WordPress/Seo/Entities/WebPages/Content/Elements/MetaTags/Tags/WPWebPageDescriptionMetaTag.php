<?php
declare( strict_types=1 );

namespace App\Domain\Integrations\WordPress\Seo\Entities\WebPages\Content\Elements\MetaTags\Tags;

use App\Domain\Base\Repo\RC\Attributes\RCLoad;
use App\Domain\Base\Repo\RC\Utils\RCApiOperations;
use App\Domain\Integrations\WordPress\Common\Entities\WPVariables;
use App\Domain\Integrations\WordPress\Seo\Entities\WebPages\Content\Elements\MetaTags\WPWebPageMetaTag;
use App\Domain\Integrations\WordPress\Seo\Entities\WebPages\Content\Elements\MetaTags\WPWebPageMetaTags;
use App\Domain\Integrations\WordPress\Seo\Repo\InternalDB\WebPages\InternalDBWPWebPageMetaTagDescription;
use App\Domain\Integrations\WordPress\Seo\Repo\RC\RCWebPageDescriptionMetaTags;
use DDD\Domain\Base\Entities\Entity;
use DDD\Domain\Base\Entities\LazyLoad\LazyLoadRepo;
use DDD\Infrastructure\Exceptions\BadRequestException;
use DDD\Infrastructure\Exceptions\ForbiddenException;
use DDD\Infrastructure\Exceptions\InternalErrorException;
use Doctrine\DBAL\Exception;
use Doctrine\Persistence\Mapping\MappingException;
use JsonException;
use Psr\Cache\InvalidArgumentException;
use RankingCoach\Inc\Core\Base\Traits\RcLoggerTrait;
use RankingCoach\Inc\Modules\ModuleLibrary\Technical\MetaTags\MetaTags;
use ReflectionException;

/**
 * Class WPWebPageDescriptionMetaTag
 * @property WPWebPageMetaTags $parent
 * @method WPWebPageMetaTags getParent()
 */
#[LazyLoadRepo(LazyLoadRepo::INTERNAL_DB, InternalDBWPWebPageMetaTagDescription::class)]
#[LazyLoadRepo(LazyLoadRepo::RC, RCWebPageDescriptionMetaTags::class)]
class WPWebPageDescriptionMetaTag extends WPWebPageMetaTag {

    use RcLoggerTrait;

    /** @var string The type of the meta tag */
    public string $type = WPWebPageMetaTag::TAG_TYPE_DESCRIPTION;

    /** @var string|null The parsed content */
    public ?string $parsed = null;

    /**
     * WPWebPageDescriptionMetaTag constructor.
     *
     * @param int $postId
     */
    public function __construct(int $postId = 0) {
        $this->type = WPWebPageMetaTag::TAG_TYPE_DESCRIPTION;
        parent::__construct($postId, $this->type);
    }

    /**
     * @return Entity
     * @throws BadRequestException
     * @throws Exception
     * @throws ForbiddenException
     * @throws InternalErrorException
     * @throws InvalidArgumentException
     * @throws JsonException
     * @throws MappingException
     * @throws ReflectionException
     * @throws \Doctrine\ORM\Mapping\MappingException
     */
    public function autoSuggest(): Entity
    {
        RCLoad::$logRCCalls = true;

        $repo = new RCWebPageDescriptionMetaTags();
        $repo->fromEntity($this);
        $repo->rcLoad(false, false);
        $entity = $repo->toEntity();

        $this->log_json([
            'operation_type' => 'meta_optimization',
            'operation_status' => 'success',
            'api_calls' => RCApiOperations::getExecutedRCCalls(),
            'context_entity' => 'post',
            'context_id' => $this->postId,
            'context_type' => get_post_type($this->postId) ?: 'unknown',
            'execution_time' => null,
            'error_details' => null,
            'metadata' => [
                'meta_tag_type' => 'description',
                'optimization_type' => 'auto_suggest',
                'original_content' => $this->content,
                'suggested_content' => $entity->content ?? null,
            ]
        ], 'description_autosuggest');
        RCLoad::$logRCCalls = false;

        $repoDB = new InternalDBWPWebPageMetaTagDescription();
        $entity->autoGenerated = true;
        $entity->variables = new WPVariables();
        $updatedEntity = $repoDB->update($entity);
        
        // Sync auto-suggested description to wp_postmeta
        if ($updatedEntity && $updatedEntity->content && $this->postId) {
            update_post_meta($this->postId, MetaTags::META_SEO_DESCRIPTION, $updatedEntity->content);
            
            // Save template and variables for future reference
            if ($updatedEntity->template) {
                update_post_meta($this->postId, MetaTags::META_SEO_DESCRIPTION . '_template', $updatedEntity->template);
            }
        }
        
        return $updatedEntity;
    }
}